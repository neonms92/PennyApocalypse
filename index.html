<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script src="lib/jquery.min.js"></script>
		<script src="lib/knockout-min.js"></script>
		<script src="lib/seedrandom.js"></script>
		<script src="lib/squares.js"></script>
		<style>
			body {
				font-family: verdana;
				text-align: center;
				background-color: lightgray;
			}
			.square.wait {
				cursor: default;
			}
		</style>
		<script>
			ko.extenders.hash = function(target, prop) {
				target.hash_defaultValue = target();
				target.hash_prop = prop;
				
				target.hash_take = function() {
					var value = ko.extenders.hash.get(target.hash_prop);
					if (typeof(value) == 'undefined')
						target(target.hash_defaultValue);
					else
						target(value);
				}
				$(window).on('hashchange', target.hash_take);
				target.hash_take();
				
				target.subscribe(function() {
					var value = target();
					if (target.hash_defaultValue == value) {
						value = null;
					}
					ko.extenders.hash.set(target.hash_prop, value);
				});
				
				return target;
			}
			ko.extenders.hash.get = function(prop) {
				var ss = (window.location.hash || '').split('#').reverse()[0].split('&');
				var s = ss.map(function(x) { return x.split('='); }).filter(function(x) { return x[0] == prop; })[0]  || [];
				return s[1];
			}
			ko.extenders.hash.set = function(prop, value) {
				var ss = (window.location.hash || '').split('#').reverse()[0].split('&').filter(function(x) { return x; });
				var index = ss.map(function(x) { return x.split('=')[0]; }).indexOf(prop);
				var newbie = prop + '=' + value;
				if (index < 0 && !!value) {
					ss.push(newbie);
				} else if (index >= 0 && !value) {
					ss.splice(index, 1);
				} else if (index >= 0 && !!value) {
					ss[index] = newbie;
				}
				window.location.hash = ss.join('&');
			}
		</script>
		<script>
			function paTimerModel() {
				var self = this;

				self.tickInterval = ko.observable(3000).extend({ hash: 'tickInterval' });
				self.actRate = ko.observable(0.30).extend({ hash: 'actRate' });
				self.advanceRate = ko.observable(0.10).extend({ hash: 'advanceRate' });
				self.mode = ko.observable(['true', 'pseudo'][0]).extend({ hash: 'mode' });

				self.checksum = ko.computed(function() {
					var rules = {};
					rules.tickInverval = self.tickInterval();
					rules.actRate = self.actRate();
					rules.advanceRate = self.advanceRate();
					rules.mode = self.mode();
					var consonants = ['b','c','d','f','g'/*,'h'*/,'j','k','l','m','n','p','r','s','t','v','w','x','y','z'];
					var vowels = ['a','e','i','o','u'];
					var r = consonants[Math.floor(squares.randomFromString(JSON.stringify(rules) + 'a') * consonants.length)]
						+ vowels[Math.floor(squares.randomFromString(JSON.stringify(rules) + 'b') * vowels.length)]
						+ consonants[Math.floor(squares.randomFromString(JSON.stringify(rules) + 'c') * consonants.length)];
					return r;
				});

				self.body_keydown = function(b, e) {
					if ([32, 13].indexOf(e.which) >= 0) {
						self.start_click();
					} else {
						return true;
					}
				}
				self.start_click = function() {
					if (self.ticking()) return;
					self.ticking(true);
					self.started(true);
					self.waiting(true);
					self.acting(false);
					self.advancing(false);
					setTimeout(self.tick, self.tickInterval());
					return true;
				}
				self.started = ko.observable(false);
				self.ticking = ko.observable(false);
				self.roll = ko.observable();
				self.acting = ko.observable(false);
				self.advancing = ko.observable(false);
				self.waiting = ko.observable(false);
				self.waitCount = ko.observable(0);
				self.ellipses = ko.computed(function() {
					var r = '';
					for (var i = 0; i < self.waitCount(); i++) {
						r += '.';
					}
					return r;
				});
				self.tick = function() {
					if (!self.ticking()) return;
					var rand = Math.random();
					self.roll(rand);
					if (rand < self.actRate()) {
						self.acting(true);
					} else if (rand >= self.actRate() && rand < self.actRate() + self.advanceRate()) {
						self.advancing(true);
					}
					self.waiting(!self.acting() && !self.advancing());

					if (self.waiting()) {
						self.waitCount(self.waitCount() + 1);
					} else {
						self.ticking(false);
						self.waitCount(0);
					}
					if (self.ticking()) setTimeout(self.tick, self.tickInterval());
				}
			}
			$(document).ready(function() {
				squares.assignOrderedColors($('.square'), 80, 40);
				squares.applyCSS();
				window.model = new paTimerModel();
				ko.applyBindings(window.model);
			});
		</script>
	</head>
	<body data-bind="event: { keydown: body_keydown }">
		<div>
			<div style="text-weight: bold; font-size: 20pt;">Penny Apocalypse Auto-Roller</div>
			<div data-bind="text: 'Ruleset: ' + checksum()"></div>
			<span class="square start" data-bind="visible: !started(), event: { click: start_click }">Start</span>
			<span class="square act" data-bind="visible: acting, event: { click: start_click }">Act!</span>
			<span class="square advance" data-bind="visible: advancing, event: { click: start_click }">Advance Monster!</span>
			<span class="square wait" data-bind="visible: waiting">Rolling<span data-bind="text: ellipses"></span></span>
		</div>
	</body>
</html>
